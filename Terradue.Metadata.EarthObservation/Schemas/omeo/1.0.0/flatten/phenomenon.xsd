<?xml version="1.0" encoding="UTF-8"?>
<schema attributeFormDefault="unqualified" elementFormDefault="qualified"
    targetNamespace="http://www.opengis.net/swe/1.0" version="1.0.0.2"
    xmlns="http://www.w3.org/2001/XMLSchema" xmlns:gml="http://www.opengis.net/gml"
    xmlns:swe="http://www.opengis.net/swe/1.0" xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <annotation>
        <documentation>phenomenon.xsd  A GML conformant schema  for definitions of phenomena, per
            Annex C of OM specification  Copyright (c) 2007,2010 Open Geospatial Consortium. To
            obtain additional rights of use, visit http://www.opengeospatial.org/legal/ .
        </documentation>
    </annotation>
    <!-- ====================================================================== -->
    <!-- bring in other schemas -->
    <import namespace="http://www.opengis.net/gml" schemaLocation="gml_8.xsd"/>
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>Stub schema for swe        Copyright (c) 2007,2010 Open Geospatial
            Consortium.    To obtain additional rights of use, visit
            http://www.opengeospatial.org/legal/ .   </xs:documentation>
    </xs:annotation>
    <!--========================-->
    <!--   <xs:include schemaLocation="./basicTypes.xsd"/>  included by simpleTypes.xsd -->
    <!--   <xs:include schemaLocation="./simpleTypes.xsd"/> included by aggregateTypes.xsd -->
    <!--   <xs:include schemaLocation="./aggregateTypes.xsd"/> included by positionTypes, curveTypes and data -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>Schema for defining position data (location, orientation, etc...) based on
            aggregate data types        Copyright (c) 2007,2010 Open Geospatial Consortium.    To
            obtain additional rights of use, visit http://www.opengeospatial.org/legal/ .
        </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>SWE Common schema for aggregate data types        Copyright (c) 2007,2010
            Open Geospatial Consortium.    To obtain additional rights of use, visit
            http://www.opengeospatial.org/legal/ .   </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="xlink.xsd"/>
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>SWE common schema for simple data types (i.e. without children)      These
            have mostly been implemented using the "composition" pattern, rather than using
            inheritance/type-derivation.  Note: In general, content model definition using
            composition is more easily accomplished using groups and attribute groups.    *
            global/named type definitions are not needed unless type derivation is required.     *
            type derivation is not needed unless substitution groups are to be supported.     *
            parent types that are too generalized will require derivation by restriction further
            down, so should be avoided.    Copyright (c) 2007,2010 Open Geospatial Consortium.   To
            obtain additional rights of use, visit http://www.opengeospatial.org/legal/ .
        </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>basicTypes.xsd  Some basic types (simpleContent) required in various
            places in OWS Sensor Web application schemas  Copyright (c) 2007,2010 Open Geospatial
            Consortium. To obtain additional rights of use, visit
            http://www.opengeospatial.org/legal/ .   </xs:documentation>
    </xs:annotation>
    <!-- ====================================================================== -->
    <!-- ====================================================================== -->
    <!-- === Units of Measure === -->
    <!-- ====================================================================== -->
    <xs:simpleType name="UomSymbol">
        <xs:annotation>
            <xs:documentation>Local copy of GML 3.2 uom symbol definition    Included for forward
                compatibility.     Note: in future of this specification based on GML 3.2, these
                will be removed in favour of the GML 3.2 implementation</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[^: \n\r\t]+"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="UomURI">
        <xs:annotation>
            <xs:documentation>Local copy of GML 3.2 uom URI definition</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:anyURI">
            <xs:pattern value="([a-zA-Z][a-zA-Z0-9\-\+\.]*:|\.\./|\./|#).*"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="UomIdentifier">
        <xs:annotation>
            <xs:documentation>Local copy of GML 3.2 uom identifier definition</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="swe:UomSymbol swe:UomURI"/>
    </xs:simpleType>
    <!-- ............ -->
    <xs:complexType name="UomPropertyType">
        <xs:annotation>
            <xs:documentation>Property type that indicates unit-of-measure, either by (i) inline
                definition; (ii)  reference; (iii)  UCUM code</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0">
            <xs:element ref="gml:UnitDefinition">
                <xs:annotation>
                    <xs:documentation>Defines a unit inline</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute form="unqualified" name="code" type="swe:UomSymbol">
            <xs:annotation>
                <xs:documentation>Specifies a unit by using a UCUM expression
                    (prefered)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup">
            <xs:annotation>
                <xs:documentation>Specifies a unit by referencing a dictionary entry (to be used
                    only for units not defined in UCUM)</xs:documentation>
            </xs:annotation>
        </xs:attributeGroup>
    </xs:complexType>
    <!-- ====================================================================== -->
    <!-- === Code space/vocabulary === -->
    <!-- ====================================================================== -->
    <xs:complexType name="CodeSpacePropertyType">
        <xs:annotation>
            <xs:documentation>Property type that indicates the codespace</xs:documentation>
        </xs:annotation>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ====================================================================== -->
    <!-- === Time position === -->
    <!-- overlaps with GML TimePositionType -->
    <!-- ====================================================================== -->
    <xs:simpleType name="timeIso8601">
        <xs:annotation>
            <xs:documentation>Choice of time position encodings, not including numeric
                representation.         A minor variation on gml:TimePositionUnion - carrying
                "indeterminate value" as content instead of an attribute.</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="xs:date xs:time xs:dateTime gml:TimeIndeterminateValueType"/>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="timePositionType">
        <xs:annotation>
            <xs:documentation>Choice of time position encodings, including numeric representation
                but no frame.   A minor variation on gml:TimePositionUnion - carrying "indeterminate
                value" as content instead of an attribute. </xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="swe:timeIso8601 xs:double"/>
    </xs:simpleType>
    <!-- ====================================================================== -->
    <!-- === Scoped Name === -->
    <!-- equivalent to GML 3.2 CodeWithAuthorityType -->
    <!-- ====================================================================== -->
    <xs:complexType name="ScopedNameType">
        <xs:annotation>
            <xs:documentation>Explicit implementation of ISO 19103 ScopedName.     Extension of
                string which also carries a codeSpace attribute.    Note: in future versions of this
                specification based on GML 3.2, this will be removed in favour of
                gml:CodeWithAuthorityType. </xs:documentation>
        </xs:annotation>
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute form="unqualified" name="codeSpace" type="xs:anyURI" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <!-- ====================================================================== -->
    <!-- === Lists === -->
    <!-- ================================================= -->
    <xs:simpleType name="decimalList">
        <xs:annotation>
            <xs:documentation>Simple list of double-precision numbers.   Note: xs:double supports
                either decimal or scientific notation</xs:documentation>
        </xs:annotation>
        <xs:list itemType="xs:double"/>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="decimalPair">
        <xs:annotation>
            <xs:documentation>Pair of double-precision numbers.   Note: xs:double supports either
                decimal or scientific notation</xs:documentation>
        </xs:annotation>
        <xs:restriction base="swe:decimalList">
            <xs:length value="2"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:simpleType name="countList">
        <xs:annotation>
            <xs:documentation>Simple list of integers. </xs:documentation>
        </xs:annotation>
        <xs:list itemType="xs:integer"/>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="countPair">
        <xs:annotation>
            <xs:documentation>Pair of integers. </xs:documentation>
        </xs:annotation>
        <xs:restriction base="swe:countList">
            <xs:length value="2"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:simpleType name="tokenList">
        <xs:annotation>
            <xs:documentation>Simple list of tokens.     Note: xs:token is a string with no embedded
                white-space allowed</xs:documentation>
        </xs:annotation>
        <xs:list itemType="xs:token"/>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:simpleType name="timeList">
        <xs:annotation>
            <xs:documentation>Simple list of time positions. </xs:documentation>
        </xs:annotation>
        <xs:list itemType="swe:timePositionType"/>
    </xs:simpleType>
    <!-- ............ -->
    <xs:simpleType name="timePair">
        <xs:annotation>
            <xs:documentation>Pair of time positions. </xs:documentation>
        </xs:annotation>
        <xs:restriction base="swe:timeList">
            <xs:length value="2"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <!-- ===== Soft-typed values ====== -->
    <!-- ====================================================================== -->
    <xs:complexType name="TypedValueType">
        <xs:annotation>
            <xs:documentation>A generic soft-typed value</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="property" type="swe:ScopedNameType">
                <xs:annotation>
                    <xs:documentation>This element attribute indicates the semantics of the typed
                        value.       Usually identifies a property or phenomenon definition.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" name="value">
                <xs:annotation>
                    <xs:documentation>Implicit xs:anyType</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <!-- ................ -->
    <xs:element name="TypedValue" type="swe:TypedValueType">
        <xs:annotation>
            <xs:documentation>A generic soft-typed value</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ................ -->
    <xs:complexType name="TypedValuePropertyType">
        <xs:annotation>
            <xs:documentation>Inline property type for soft-typed values</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:TypedValue"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ====================================================================== -->
    <xs:complexType name="TypedValueListType">
        <xs:annotation>
            <xs:documentation>A list of generic soft-typed values</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="property" type="swe:ScopedNameType">
                <xs:annotation>
                    <xs:documentation>This element attribute indicates the semantics of the typed
                        value.       Usually identifies a property or phenomenon definition.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" maxOccurs="unbounded" name="value">
                <xs:annotation>
                    <xs:documentation>Implicit xs:anyType</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <!-- ................ -->
    <xs:element name="TypedValueList" type="swe:TypedValueListType">
        <xs:annotation>
            <xs:documentation>A generic soft-typed list of values</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ................ -->
    <xs:complexType name="TypedValueListPropertyType">
        <xs:annotation>
            <xs:documentation>Inline property type for list of generic soft-typed
                values</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:TypedValueList"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ====================================================================== -->
    <!-- === Generic Interval === -->
    <!-- ====================================================================== -->
    <xs:complexType name="IntervalType">
        <xs:annotation>
            <xs:documentation>A generic interval. The type of the two limits will normally be the
                same.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element form="qualified" name="lowerBound">
                <xs:annotation>
                    <xs:documentation>Implicit xs:anyType</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" name="upperBound">
                <xs:annotation>
                    <xs:documentation>Implicit xs:anyType</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <!-- ................ -->
    <xs:element name="Interval" type="swe:IntervalType">
        <xs:annotation>
            <xs:documentation>A generic interval. The type of the two limits will normally be the
                same.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ................ -->
    <xs:complexType name="IntervalPropertyType">
        <xs:annotation>
            <xs:documentation>Inline property type for generic intervals</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Interval"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ====================================================================== -->
    <!-- ================================================= -->
    <!-- === Root class model === -->
    <!-- ================================================= -->
    <xs:complexType abstract="true" name="AbstractDataComponentType">
        <xs:annotation>
            <xs:documentation>Base type for all data components.     This is implemented as an XML
                Schema complexType because it includes both element and attribute
                content.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="gml:AbstractGMLType">
                <xs:attribute default="false" form="unqualified" name="fixed" type="xs:boolean"
                    use="optional">
                    <xs:annotation>
                        <xs:documentation>Specifies if the value of a component stays fixed in time
                            or is variable. Default is variable</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute form="unqualified" name="definition" type="xs:anyURI" use="optional">
                    <xs:annotation>
                        <xs:documentation>Points to semantics information defining the precise
                            nature of the component</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <!--                 Simple Components                 -->
    <!-- ================================================= -->
    <xs:attributeGroup name="SimpleComponentAttributeGroup">
        <xs:annotation>
            <xs:documentation>Basic attributes required for all simple data components (i.e. without
                children)</xs:documentation>
        </xs:annotation>
        <xs:attribute form="unqualified" name="referenceFrame" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation>A reference frame anchors a value to a datum or interval
                    scale</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="axisID" type="xs:token" use="optional">
            <xs:annotation>
                <xs:documentation>Specifies the reference axis using the gml:axisID. The reference
                    frame URI is inherited from parent Vector</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- ================================================= -->
    <!-- ======== Booleans ============= -->
    <!-- ================================================= -->
    <xs:element name="Boolean">
        <xs:annotation>
            <xs:documentation>Scalar component used to express truth: True or False, 0 or
                1</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="quality"
                            type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="BooleanPropertyType">
        <xs:annotation>
            <xs:documentation>Boolean is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Boolean"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ======== Quantities ============= -->
    <!-- ================================================= -->
    <xs:element name="Quantity">
        <xs:annotation>
            <xs:documentation>Decimal number with optional unit and constraints</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="uom"
                            type="swe:UomPropertyType">
                            <xs:annotation>
                                <xs:documentation>Unit of measure</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedValuesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                            name="quality" type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="QuantityPropertyType">
        <xs:annotation>
            <xs:documentation>Quantity is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Quantity"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="QuantityRange">
        <xs:annotation>
            <xs:documentation>Decimal pair for specifying a quantity range with
                constraints</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="uom"
                            type="swe:UomPropertyType">
                            <xs:annotation>
                                <xs:documentation>Unit of measure</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedValuesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                            name="quality" type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value"
                            type="swe:decimalPair">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <!-- *** Maybe cleaner to implement as a pair of value elements? *** -->
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="QuantityRangePropertyType">
        <xs:annotation>
            <xs:documentation>QuantityRange is a data-type so usually appears "by value" rather than
                by reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:QuantityRange"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="Count">
        <xs:annotation>
            <xs:documentation>Integer number used for a counting value</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedValuesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                            name="quality" type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="xs:integer">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <!--
						<xs:element name="uom" type="swe:UomPropertyType" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Unit of measure</xs:documentation>
							</xs:annotation> 
						If there is a UOM then it is a scaled Quantity, not a Count. 
						</xs:element>
						-->
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="CountPropertyType">
        <xs:annotation>
            <xs:documentation>Count is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Count"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="CountRange">
        <xs:annotation>
            <xs:documentation>Integer pair used for specifying a count range</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedValuesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
                            name="quality" type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="swe:countPair">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                            <!-- *** Maybe cleaner to implement as a pair of value elements? *** -->
                        </xs:element>
                        <!--
						<xs:element name="uom" type="swe:UomPropertyType" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Unit of measure</xs:documentation>
							</xs:annotation> 
						If there is a UOM then it is a scaled Quantity, not a Count. 
						</xs:element>
						-->
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="CountRangePropertyType">
        <xs:annotation>
            <xs:documentation>CountRange is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:CountRange"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ======== Categories ============= -->
    <!-- ================================================= -->
    <xs:element name="Category">
        <xs:annotation>
            <xs:documentation>A simple token identifying a term or category (single spaces allowed);
                definition attribute should provide dictionary entry useful for interpretation of
                the value</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="codeSpace"
                            type="swe:CodeSpacePropertyType">
                            <xs:annotation>
                                <xs:documentation>Provides link to dictionary or rule set to which
                                    the value belongs</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedTokensPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as an enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="quality"
                            type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="xs:token">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:SimpleComponentAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="CategoryPropertyType">
        <xs:annotation>
            <xs:documentation>Category is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Category"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ========== Time Components ======== -->
    <!-- ================================================= -->
    <xs:attributeGroup name="TRSAttributeGroup">
        <xs:attribute form="unqualified" name="referenceTime" type="swe:timeIso8601" use="optional">
            <xs:annotation>
                <xs:documentation>Specifies the origin of the temporal reference frame as an ISO8601
                    date (used to specify time after an epoch)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="referenceFrame" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation>Points to a temporal reference frame definition. Time value will
                    be expressed relative to this frame</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute form="unqualified" name="localFrame" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation>Specifies the temporal frame which origin is given by this time
                    component</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <!-- ================================================= -->
    <xs:element name="Time">
        <xs:annotation>
            <xs:documentation>Either ISO 8601 (e.g. 2004-04-18T12:03:04.6Z) or time relative to a
                time origin</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="uom"
                            type="swe:UomPropertyType">
                            <xs:annotation>
                                <xs:documentation>Unit of measure</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedTimesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="quality"
                            type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value"
                            type="swe:timePositionType">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:TRSAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="TimePropertyType">
        <xs:annotation>
            <xs:documentation>Time is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Time"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="TimeRange">
        <xs:annotation>
            <xs:documentation>Time value pair for specifying a time range (can be a decimal or ISO
                8601)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="uom"
                            type="swe:UomPropertyType">
                            <xs:annotation>
                                <xs:documentation>Unit of measure</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="constraint"
                            type="swe:AllowedTimesPropertyType">
                            <xs:annotation>
                                <xs:documentation>The constraint property defines the permitted
                                    values, as a range or enumerated list</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="quality"
                            type="swe:QualityPropertyType">
                            <xs:annotation>
                                <xs:documentation>The quality property provides an indication of the
                                    reliability of estimates of the asociated
                                    value</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element form="qualified" minOccurs="0" name="value" type="swe:timePair">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                            <!-- *** Maybe cleaner to implement as a pair of value elements? *** -->
                        </xs:element>
                    </xs:sequence>
                    <xs:attributeGroup ref="swe:TRSAttributeGroup"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="TimeRangePropertyType">
        <xs:annotation>
            <xs:documentation>TimeRange is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:TimeRange"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ======== Text Object  ============= -->
    <!-- ================================================= -->
    <xs:element name="Text">
        <xs:annotation>
            <xs:documentation>Free textual component</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType">
                    <xs:sequence>
                        <xs:element form="qualified" minOccurs="0" name="value" type="xs:string">
                            <xs:annotation>
                                <xs:documentation>Value is optional, to enable structure to act in a
                                    schema for values provided using other
                                    encodings</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="TextPropertyType">
        <xs:annotation>
            <xs:documentation>Text is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Text"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ======== ObservableProperty ============= -->
    <!-- ================================================= -->
    <xs:element name="ObservableProperty">
        <xs:annotation>
            <xs:documentation>ObservableProperty should be used to identify (through reference only)
                stimuli or measurable property types. The consequence is that it does not have a uom
                because it has not been measured yet.  This is used to define
                sensor/detector/actuator inputs and outputs, for instance.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractDataComponentType"/>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <!-- ============ Constraints and Qualifiers ================ -->
    <!-- ================================================= -->
    <xs:complexType name="QualityPropertyType">
        <xs:annotation>
            <xs:documentation>Allows for a simple quality assessment of the values carried by this
                component.        This value can be numerical or categorical thus allowing for
                things like accuracy, precision, tolerance, confidence level, etc...
                The  meaning of the quality measure is indicated by the definition attribute of the
                chosen sub-component.                The use of the 'ref'attribute indicate that the
                value of accuracy is included itself in the data inside the referred component.
                This soft-typed Data Quality description may be replaced by ISO 19115/19139
                DQ_DataQuality elements in later versions</xs:documentation>
        </xs:annotation>
        <xs:choice minOccurs="0">
            <xs:element ref="swe:Quantity"/>
            <xs:element ref="swe:QuantityRange"/>
            <xs:element ref="swe:Category"/>
            <xs:element ref="swe:Text"/>
        </xs:choice>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:complexType name="AllowedValuesPropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:AllowedValues"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:element name="AllowedValues">
        <xs:annotation>
            <xs:documentation>List of allowed values (There is an implicit AND between all
                members)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:choice>
                    <xs:element form="qualified" name="min" type="xs:double">
                        <xs:annotation>
                            <xs:documentation>Specifies minimum allowed value for an open interval
                                (no max)</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="max" type="xs:double">
                        <xs:annotation>
                            <xs:documentation>Specifies maximum allowed value for an open interval
                                (no min)</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
                <xs:choice maxOccurs="unbounded">
                    <xs:element form="qualified" name="interval" type="swe:decimalPair">
                        <xs:annotation>
                            <xs:documentation>Range of allowed values (closed interval) for this
                                component</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="valueList" type="swe:decimalList">
                        <xs:annotation>
                            <xs:documentation>List of allowed values for this
                                component</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
            </xs:choice>
            <xs:attribute form="unqualified" name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <xs:complexType name="AllowedTokensPropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:AllowedTokens"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:element name="AllowedTokens">
        <xs:annotation>
            <xs:documentation>Enumeration of allowed values</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element form="qualified" maxOccurs="unbounded" name="valueList"
                    type="swe:tokenList">
                    <xs:annotation>
                        <xs:documentation>List of allowed token values for this
                            component</xs:documentation>
                    </xs:annotation>
                    <!-- why tokens? Better to allow strings. In which case either the members must be tagged, or whitespace escaped -->
                    <!-- the Category component is limited to the use of tokens to simplify comparisons (remove possible confusions due to
					     insertion of \n or double spaces). Free Strings are only used in the Text component -->
                </xs:element>
            </xs:sequence>
            <xs:attribute form="unqualified" name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <xs:complexType name="AllowedTimesPropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:AllowedTimes"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:element name="AllowedTimes">
        <xs:annotation>
            <xs:documentation>List of allowed time values (There is an implicit AND between all
                members)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:choice>
                    <xs:element form="qualified" name="min" type="swe:timePositionType">
                        <xs:annotation>
                            <xs:documentation>Specifies minimum allowed time value for an open
                                interval (no max)</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="max" type="swe:timePositionType">
                        <xs:annotation>
                            <xs:documentation>Specifies maximum allowed time value for an open
                                interval (no min)</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
                <xs:choice maxOccurs="unbounded">
                    <xs:element form="qualified" name="interval" type="swe:timePair">
                        <xs:annotation>
                            <xs:documentation>Range of allowed time values (closed interval) for
                                this component</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="valueList" type="swe:timeList">
                        <xs:annotation>
                            <xs:documentation>List of allowed time values for this
                                component</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
            </xs:choice>
            <xs:attribute form="unqualified" name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <!--               Data Component Groups               -->
    <!-- ================================================= -->
    <xs:group name="AnyScalar">
        <xs:annotation>
            <xs:documentation>Re-usable group providing a choice of scalar data
                types</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:group ref="swe:AnyNumerical"/>
            <xs:element ref="swe:Boolean"/>
            <xs:element ref="swe:Category"/>
            <xs:element ref="swe:Text"/>
        </xs:choice>
    </xs:group>
    <!-- ........ -->
    <xs:complexType name="AnyScalarPropertyType">
        <xs:annotation>
            <xs:documentation>Complex Type for all properties taking the AnyScalar
                Group</xs:documentation>
        </xs:annotation>
        <xs:group minOccurs="0" ref="swe:AnyScalar"/>
        <xs:attribute form="unqualified" name="name" type="xs:token" use="required"/>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:group name="AnyNumerical">
        <xs:annotation>
            <xs:documentation>Re-usable group providing a choice of numeric data
                types</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="swe:Count"/>
            <xs:element ref="swe:Quantity"/>
            <xs:element ref="swe:Time"/>
        </xs:choice>
    </xs:group>
    <!-- ........ -->
    <xs:group name="AnyRange">
        <xs:annotation>
            <xs:documentation>Re-usable group providing a choice of range data
                types</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="swe:QuantityRange"/>
            <xs:element ref="swe:CountRange"/>
            <xs:element ref="swe:TimeRange"/>
        </xs:choice>
    </xs:group>
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>Defines basic ResponseType definition and commonly used sensor
            characteristics        Copyright (c) 2007,2010 Open Geospatial Consortium.    To obtain
            additional rights of use, visit http://www.opengeospatial.org/legal/ .
        </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:complexType name="BlockEncodingPropertyType">
        <xs:choice minOccurs="0">
            <xs:element ref="swe:StandardFormat"/>
            <xs:element ref="swe:BinaryBlock"/>
            <xs:element ref="swe:TextBlock"/>
            <xs:element ref="swe:XMLBlock"/>
        </xs:choice>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:complexType name="AbstractEncodingType">
        <xs:attribute form="unqualified" name="id" type="xs:ID"/>
        <!-- why bother with the supertype? Not used to form a substitution group. -->
        <!--->Remember - attributes are Optional by default -->
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:element name="StandardFormat">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractEncodingType">
                    <xs:attribute form="unqualified" name="mimeType" type="xs:token" use="required"
                    />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:element name="TextBlock">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractEncodingType">
                    <xs:attribute form="unqualified" name="tokenSeparator" type="swe:textSeparator"
                        use="required"/>
                    <xs:attribute form="unqualified" name="blockSeparator" type="swe:textSeparator"
                        use="required"/>
                    <xs:attribute form="unqualified" name="decimalSeparator"
                        type="swe:decimalSeparator" use="required"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <xs:simpleType name="textSeparator">
        <xs:annotation>
            <xs:documentation>Max three characters to use as token or block
                separator</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:maxLength value="3"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:simpleType name="decimalSeparator">
        <xs:annotation>
            <xs:documentation>One character to use as a decimal separator</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token">
            <xs:length value="1"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:element name="BinaryBlock">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractEncodingType">
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="member">
                            <xs:complexType>
                                <xs:choice>
                                    <xs:element form="qualified" name="Component">
                                        <xs:complexType>
                                            <xs:attribute form="unqualified" name="ref"
                                                type="xs:token" use="required"/>
                                            <xs:attribute form="unqualified" name="dataType"
                                                type="xs:anyURI" use="optional"/>
                                            <xs:attribute form="unqualified" name="significantBits"
                                                type="xs:positiveInteger" use="optional"/>
                                            <xs:attribute form="unqualified" name="bitLength"
                                                type="xs:positiveInteger" use="optional"/>
                                            <xs:attribute default="0" form="unqualified"
                                                name="paddingBits-before"
                                                type="xs:nonNegativeInteger" use="optional"/>
                                            <xs:attribute default="0" form="unqualified"
                                                name="paddingBits-after"
                                                type="xs:nonNegativeInteger" use="optional"/>
                                            <xs:attribute form="unqualified" name="encryption"
                                                type="xs:anyURI" use="optional"/>
                                        </xs:complexType>
                                    </xs:element>
                                    <xs:element form="qualified" name="Block">
                                        <xs:complexType>
                                            <xs:attribute form="unqualified" name="ref"
                                                type="xs:token" use="required"/>
                                            <xs:attribute form="unqualified" name="byteLength"
                                                type="xs:positiveInteger" use="optional"/>
                                            <xs:attribute default="0" form="unqualified"
                                                name="paddingBytes-before"
                                                type="xs:nonNegativeInteger" use="optional"/>
                                            <xs:attribute default="0" form="unqualified"
                                                name="paddingBytes-after"
                                                type="xs:nonNegativeInteger" use="optional"/>
                                            <xs:attribute form="unqualified" name="encryption"
                                                type="xs:anyURI" use="optional"/>
                                            <xs:attribute form="unqualified" name="compression"
                                                type="xs:anyURI" use="optional"/>
                                        </xs:complexType>
                                    </xs:element>
                                </xs:choice>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                    <xs:attribute form="unqualified" name="byteLength" type="xs:positiveInteger"
                        use="optional"/>
                    <xs:attribute form="unqualified" name="byteEncoding" type="swe:byteEncoding"
                        use="required"/>
                    <xs:attribute form="unqualified" name="byteOrder" type="swe:byteOrder"
                        use="required"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <xs:simpleType name="byteEncoding">
        <xs:restriction base="xs:token">
            <xs:enumeration value="base64"/>
            <xs:enumeration value="raw"/>
            <xs:enumeration value="hex"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:simpleType name="byteOrder">
        <xs:restriction base="xs:token">
            <xs:enumeration value="bigEndian"/>
            <xs:enumeration value="littleEndian"/>
        </xs:restriction>
    </xs:simpleType>
    <!-- ================================================= -->
    <xs:element name="MultiplexedStreamFormat" type="swe:MultiplexedStreamFormatType">
        <xs:annotation>
            <xs:documentation>Allows specification of the stream/packaging format used (ex: RTP,
                ASF, AAF, TML...)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="MultiplexedStreamFormatType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractEncodingType">
                <xs:attribute form="unqualified" name="type" type="xs:anyURI" use="required"/>
                <xs:attribute form="unqualified" name="version" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="MultiplexedStreamFormatPropertyType">
        <xs:sequence>
            <xs:element minOccurs="0" ref="swe:MultiplexedStreamFormat"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:element name="XMLBlock" type="swe:XMLBlockType">
        <xs:annotation>
            <xs:documentation>Carries the designator for an element implementing an XML-encoded
                data-type</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="XMLBlockType">
        <xs:annotation>
            <xs:documentation>Carries the designator for an element implementing an XML-encoded
                data-type</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="swe:AbstractEncodingType">
                <xs:attribute form="unqualified" name="xmlElement" type="xs:QName">
                    <xs:annotation>
                        <xs:documentation>May be any XML Schema defined global element.    typically
                            this will be swe:Array, swe:Record, cv:CV_DiscreteCoverage,
                            etc</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <!--         Composite/Aggregate Components - Records and arrays            -->
    <!-- ================================================= -->
    <xs:element abstract="true" name="AbstractDataRecord" type="swe:AbstractDataRecordType"/>
    <!-- ........ -->
    <xs:complexType abstract="true" name="AbstractDataRecordType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataComponentType"/>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="DataRecord" substitutionGroup="swe:AbstractDataRecord"
        type="swe:DataRecordType">
        <xs:annotation>
            <xs:documentation>Implementation of ISO-11404 Record datatype. This allows grouping of
                data components which can themselves be Records, Arrays or Simple
                Types</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="DataRecordType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="field"
                        type="swe:DataComponentPropertyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="DataRecordPropertyType">
        <xs:annotation>
            <xs:documentation>DataRecord is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:DataRecord"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="SimpleDataRecord" substitutionGroup="swe:AbstractDataRecord"
        type="swe:SimpleDataRecordType">
        <xs:annotation>
            <xs:documentation>Implementation of ISO-11404 Record datatype that takes only simple
                scalars (i.e. no data aggregates)</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="SimpleDataRecordType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="field"
                        type="swe:AnyScalarPropertyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="SimpleDataRecordPropertyType">
        <xs:annotation>
            <xs:documentation>SimpleDataRecord is a data-type so usually appears "by value" rather
                than by reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:SimpleDataRecord"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element abstract="true" name="AbstractDataArray" type="swe:AbstractDataArrayType">
        <xs:annotation>
            <xs:documentation>Implemetation of ISO-11404 Array datatype. This defines an array of
                identical data components with a elementCount. Values are given as a block and can
                be encoded in different ways</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType abstract="true" name="AbstractDataArrayType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataComponentType">
                <xs:sequence>
                    <xs:element form="qualified" name="elementCount">
                        <xs:annotation>
                            <xs:documentation>Specifies the size of the array (i.e. the number of
                                elements of the defined type it contains)</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence minOccurs="0">
                                <xs:element ref="swe:Count">
                                    <!-- Should this really be swe:Count rather than xs:integer??? -->
                                </xs:element>
                                <!-- maxOccurs="unbounded" to support multiple dimensions? -->
                            </xs:sequence>
                            <xs:attribute form="unqualified" name="ref" type="xs:IDREF">
                                <xs:annotation>
                                    <xs:documentation>If present, the array size is variable and
                                        should be obtained from the referenced component.
                                        The referenced component must occur before the array values
                                        in a data stream to allow parsing.</xs:documentation>
                                </xs:annotation>
                            </xs:attribute>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="DataArray" substitutionGroup="swe:AbstractDataArray" type="swe:DataArrayType">
        <xs:annotation>
            <xs:documentation>Implemetation of ISO-11404 Array datatype. This defines an array of
                identical data components with a elementCount. Values are given as a block and can
                be encoded in different ways</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="DataArrayType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataArrayType">
                <xs:sequence>
                    <xs:element form="qualified" name="elementType"
                        type="swe:DataComponentPropertyType"/>
                    <xs:group minOccurs="0" ref="swe:EncodedValuesGroup"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="DataArrayPropertyType">
        <xs:annotation>
            <xs:documentation>DataArray is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:DataArray"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:complexType name="DataValuePropertyType">
        <xs:annotation>
            <xs:documentation>Use to point or include data values inline</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="xs:anyType">
                <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <!--         Conditionals            -->
    <!-- ================================================= -->
    <xs:element name="ConditionalData" substitutionGroup="swe:AbstractDataRecord"
        type="swe:ConditionalDataType">
        <xs:annotation>
            <xs:documentation>List of Conditional Values for a property</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="ConditionalDataType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" name="case">
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element minOccurs="0" ref="swe:ConditionalValue"/>
                            </xs:sequence>
                            <xs:attribute form="unqualified" name="name" type="xs:token"
                                use="required"/>
                            <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:complexType name="AbstractConditionalType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" name="condition">
                        <xs:annotation>
                            <xs:documentation>Specifies one or more conditions for which the given
                                value is valid</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:group minOccurs="0" ref="swe:AnyData"/>
                            <xs:attribute form="unqualified" name="name" type="xs:token"
                                use="required"/>
                            <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="ConditionalValue" substitutionGroup="swe:AbstractDataRecord"
        type="swe:ConditionalValueType">
        <xs:annotation>
            <xs:documentation>Qualifies data (scalar or not) with one or more
                conditions</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="ConditionalValueType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractConditionalType">
                <xs:sequence>
                    <xs:element form="qualified" name="data">
                        <xs:complexType>
                            <xs:group minOccurs="0" ref="swe:AnyData"/>
                            <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <!--               Data Component Groups               -->
    <!-- ================================================= -->
    <xs:group name="AnyData">
        <xs:choice>
            <xs:group ref="swe:AnyScalar"/>
            <xs:group ref="swe:AnyRange"/>
            <xs:element ref="swe:AbstractDataRecord"/>
            <xs:element ref="swe:AbstractDataArray"/>
        </xs:choice>
    </xs:group>
    <!-- ........ -->
    <xs:complexType name="DataComponentPropertyType">
        <xs:annotation>
            <xs:documentation>Complex Type for all properties taking the AnyData
                Group</xs:documentation>
        </xs:annotation>
        <xs:group minOccurs="0" ref="swe:AnyData"/>
        <xs:attribute form="unqualified" name="name" type="xs:token" use="required"/>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="SimpleDataPropertyType">
        <xs:annotation>
            <xs:documentation>Supports a DataGroup/DataArray with inline data
                values</xs:documentation>
        </xs:annotation>
        <xs:group minOccurs="0" ref="swe:AnyData"/>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:group name="EncodedValuesGroup">
        <xs:sequence>
            <xs:element form="qualified" name="encoding" type="swe:BlockEncodingPropertyType">
                <xs:annotation>
                    <xs:documentation>Specifies an encoding for the data structure defined by the
                        enclosing element</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element form="qualified" name="values" type="swe:DataValuePropertyType">
                <xs:annotation>
                    <xs:documentation>Carries the block of values encoded as specified by the
                        encoding element</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <!-- ================================================= -->
    <xs:element name="Position" substitutionGroup="swe:AbstractDataRecord" type="swe:PositionType">
        <xs:annotation>
            <xs:documentation>Position is given as a group of Vectors/Matrices, each of which can
                specify location, orientation, velocity, angularVelocity, acceleration or
                angularAcceleration or a combination of those in a composite state Vector. Each
                Vector can have a separate frame of reference or inherit the frame from the parent
                Position object.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="PositionType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractVectorType">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="time"
                        type="swe:TimePropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="location"
                        type="swe:VectorPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="orientation"
                        type="swe:VectorOrSquareMatrixPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="velocity"
                        type="swe:VectorPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="angularVelocity"
                        type="swe:VectorOrSquareMatrixPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="acceleration"
                        type="swe:VectorPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="angularAcceleration"
                        type="swe:VectorOrSquareMatrixPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="state"
                        type="swe:VectorOrSquareMatrixPropertyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:complexType name="AbstractMatrixType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataArrayType">
                <xs:attribute form="unqualified" name="referenceFrame" type="xs:anyURI"
                    use="optional">
                    <xs:annotation>
                        <xs:documentation>Points to a spatial reference frame definition.
                            Coordinates of the vector will be expressed in this reference
                            frame</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute form="unqualified" name="localFrame" type="xs:anyURI" use="optional">
                    <xs:annotation>
                        <xs:documentation>Specifies the spatial frame which location and/or
                            orientation is given by the enclosing vector</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="SquareMatrix" substitutionGroup="swe:AbstractDataArray"
        type="swe:SquareMatrixType">
        <xs:annotation>
            <xs:documentation>This is a square matrix (so the size is the square of one dimension)
                which is a DataArray of Quantities.   It has a referenceFrame in which the matrix
                components are described</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="SquareMatrixType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractMatrixType">
                <xs:sequence>
                    <xs:element form="qualified" name="elementType" type="swe:QuantityPropertyType"/>
                    <xs:group minOccurs="0" ref="swe:EncodedValuesGroup"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="VectorOrSquareMatrixPropertyType">
        <xs:annotation>
            <xs:documentation>Vector/SquareMatrix is a data-type so usually appears "by value"
                rather than by reference.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="swe:Vector"/>
            <xs:element ref="swe:SquareMatrix"/>
        </xs:choice>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- Areas and Envelopes -->
    <!-- ================================================= -->
    <xs:element name="GeoLocationArea" substitutionGroup="swe:AbstractDataRecord">
        <xs:annotation>
            <xs:documentation>Area used to define bounding boxes</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="swe:AbstractVectorType">
                    <xs:sequence>
                        <xs:element form="qualified" maxOccurs="unbounded" name="member"
                            type="swe:EnvelopePropertyType">
                            <xs:annotation>
                                <xs:documentation>Is this an aggregate geometry?</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attribute form="unqualified" name="name" type="xs:token"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <!-- ================================================= -->
    <xs:element name="Envelope" substitutionGroup="swe:AbstractDataRecord" type="swe:EnvelopeType">
        <xs:annotation>
            <xs:documentation>Envelope described using two vectors specifying lower and upper corner
                points.            This is typically use to define rectangular bounding boxes in any
                coordinate system.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="EnvelopeType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractVectorType">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="time"
                        type="swe:TimeRangePropertyType">
                        <xs:annotation>
                            <xs:documentation>Optionally provides time range during which this
                                bounding envelope applies</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element form="qualified" name="lowerCorner" type="swe:VectorPropertyType"/>
                    <xs:element form="qualified" name="upperCorner" type="swe:VectorPropertyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="EnvelopePropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:Envelope"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!--         Composite/Aggregate Components - Vectors and Matrices            -->
    <!-- ================================================= -->
    <xs:complexType abstract="true" name="AbstractVectorType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:attribute form="unqualified" name="referenceFrame" type="xs:anyURI"
                    use="optional">
                    <xs:annotation>
                        <xs:documentation>Points to a spatial reference frame definition.
                            Coordinates of the vector will be expressed in this reference
                            frame</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute form="unqualified" name="localFrame" type="xs:anyURI" use="optional">
                    <xs:annotation>
                        <xs:documentation>Specifies the spatial frame which location and/or
                            orientation is given by the enclosing vector</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="Vector" substitutionGroup="swe:AbstractDataRecord" type="swe:VectorType">
        <xs:annotation>
            <xs:documentation>A Vector is a special type of DataRecord that takes a list of
                numerical scalars called coordinates. The Vector has a referenceFrame in which the
                coordinates are expressed</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ............... -->
    <xs:complexType name="VectorType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractVectorType">
                <xs:sequence>
                    <xs:element form="qualified" maxOccurs="unbounded" name="coordinate">
                        <xs:complexType>
                            <xs:group minOccurs="0" ref="swe:AnyNumerical"/>
                            <xs:attribute form="unqualified" name="name" type="xs:token"
                                use="required"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="VectorPropertyType">
        <xs:annotation>
            <xs:documentation>Vector is a data-type so usually appears "by value" rather than by
                reference. However, by reference is still useful when objects, for instance, share a
                location.</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:Vector"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>Schema for defining different types of curves based on aggregate data
            types        Copyright (c) 2007,2010 Open Geospatial Consortium.    To obtain additional
            rights of use, visit http://www.opengeospatial.org/legal/ .   </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <!--                  Curve Components                 -->
    <!-- ================================================= -->
    <xs:element name="Curve" substitutionGroup="swe:AbstractDataArray" type="swe:CurveType">
        <xs:annotation>
            <xs:documentation>Curve describing variations of a parameter vs. another
                quantity</xs:documentation>
        </xs:annotation>
    </xs:element>
    <!-- ........ -->
    <xs:complexType name="CurveType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataArrayType">
                <xs:sequence>
                    <xs:element form="qualified" name="elementType"
                        type="swe:SimpleDataRecordPropertyType"/>
                    <xs:group minOccurs="0" ref="swe:EncodedValuesGroup"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="CurvePropertyType">
        <xs:annotation>
            <xs:documentation>Curve is a data-type so usually appears "by value" rather than by
                reference.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="swe:Curve"/>
        </xs:sequence>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="NormalizedCurve" substitutionGroup="swe:AbstractDataRecord"
        type="swe:NormalizedCurveType"/>
    <xs:complexType name="NormalizedCurveType">
        <xs:complexContent>
            <xs:extension base="swe:AbstractDataRecordType">
                <xs:sequence>
                    <xs:element form="qualified" minOccurs="0" name="inputGain"
                        type="swe:QuantityPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="inputBias"
                        type="swe:QuantityPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="outputGain"
                        type="swe:QuantityPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="outputBias"
                        type="swe:QuantityPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="interpolationMethod"
                        type="swe:CategoryPropertyType"/>
                    <xs:element form="qualified" minOccurs="0" name="extrapolationMethod"
                        type="swe:CategoryPropertyType"/>
                    <xs:element form="qualified" name="function" type="swe:CurvePropertyType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!-- ================================================= -->
    <!--               Data Component Groups               -->
    <!-- ================================================= -->
    <xs:group name="Curves">
        <xs:choice>
            <xs:element ref="swe:Curve"/>
            <xs:element ref="swe:NormalizedCurve"/>
        </xs:choice>
    </xs:group>
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <xs:annotation>
        <xs:documentation>Schema allowing definition of structure and encoding of sensor data.
            Multiplexed streams can also be described            Copyright (c) 2007,2010 Open
            Geospatial Consortium.      To obtain additional rights of use, visit
            http://www.opengeospatial.org/legal/ .   </xs:documentation>
    </xs:annotation>
    <!-- ================================================= -->
    <!-- ================================================= -->
    <xs:element name="DataBlockDefinition" type="swe:DataBlockDefinitionType"/>
    <!-- ........ -->
    <xs:complexType name="DataBlockDefinitionType">
        <xs:sequence>
            <xs:element form="qualified" name="components" type="swe:DataComponentPropertyType"/>
            <xs:element form="qualified" name="encoding" type="swe:BlockEncodingPropertyType"/>
        </xs:sequence>
        <xs:attribute form="unqualified" name="id" type="xs:ID" use="optional"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="DataBlockDefinitionPropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:DataBlockDefinition"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <xs:element name="DataStreamDefinition" type="swe:DataStreamDefinitionType"/>
    <!-- ........ -->
    <xs:complexType name="DataStreamDefinitionType">
        <xs:sequence>
            <xs:element form="qualified" maxOccurs="unbounded" name="streamComponent"
                type="swe:DataBlockDefinitionPropertyType"/>
            <xs:element form="qualified" name="streamEncoding"
                type="swe:MultiplexedStreamFormatPropertyType"/>
        </xs:sequence>
        <xs:attribute form="unqualified" name="id" type="xs:ID" use="optional"/>
    </xs:complexType>
    <!-- ........ -->
    <xs:complexType name="DataStreamDefinitionPropertyType">
        <xs:sequence minOccurs="0">
            <xs:element ref="swe:DataStreamDefinition"/>
        </xs:sequence>
        <xs:attributeGroup ref="gml:AssociationAttributeGroup"/>
    </xs:complexType>
    <!-- ================================================= -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <annotation>
        <documentation> temporalAggregates.xsd  time geometric complex, time aggregates and time
            grids  Copyright (c) 2007,2010 Open Geospatial Consortium. To obtain additional rights
            of use, visit http://www.opengeospatial.org/legal/ .   </documentation>
    </annotation>
    <!-- ====================================================================== -->
    <!-- bring in other schemas -->
    <!-- ================================================================== -->
    <!-- =========================================================== -->
    <!-- ============================================================== -->
    <simpleType name="TimeValueList">
        <annotation>
            <documentation>Compact list of time instants, following gml:posList pattern.
            </documentation>
        </annotation>
        <list itemType="gml:TimePositionUnion"/>
    </simpleType>
    <!-- ====================================================================== -->
    <complexType name="TimePositionListType">
        <annotation>
            <documentation>TimePositionList instances hold a sequence of time positions within the
                same frame.</documentation>
        </annotation>
        <simpleContent>
            <extension base="swe:TimeValueList">
                <attribute default="#ISO-8601" form="unqualified" name="frame" type="anyURI"
                    use="optional"/>
                <attribute form="unqualified" name="calendarEraName" type="string" use="optional"/>
                <attribute form="unqualified" name="indeterminatePosition"
                    type="gml:TimeIndeterminateValueType" use="optional"/>
                <attribute form="unqualified" name="count" type="positiveInteger" use="optional">
                    <annotation>
                        <documentation>"count" allows to specify the number of direct positions in
                            the list. </documentation>
                    </annotation>
                </attribute>
            </extension>
        </simpleContent>
    </complexType>
    <!-- ============================================================== -->
    <!-- ===== Missing property types ====== -->
    <!-- ================================================================== -->
    <complexType name="TimeGeometricPrimitivePropertyType">
        <annotation>
            <documentation>Property type not provided by GML</documentation>
        </annotation>
        <sequence minOccurs="0">
            <element ref="gml:_TimeGeometricPrimitive"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ================================================================== -->
    <!-- ===== Time geometric complexes ====== -->
    <!-- ================================================================== -->
    <complexType name="TimeGeometricComplexType">
        <annotation>
            <documentation>Explicit implementation of ISO 19108 TM_GeometricComplex - a
                self-consistent set of TimeInstants and TimePeriods</documentation>
        </annotation>
        <complexContent>
            <extension base="gml:AbstractTimeComplexType">
                <sequence>
                    <element form="qualified" maxOccurs="unbounded" name="primitive"
                        type="swe:TimeGeometricPrimitivePropertyType">
                        <annotation>
                            <documentation>Reference to an identified time primitive</documentation>
                        </annotation>
                    </element>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ......................... -->
    <element name="TimeGeometricComplex" substitutionGroup="gml:_TimeComplex"
        type="swe:TimeGeometricComplexType">
        <annotation>
            <documentation>Explicit implementation of ISO 19108 TM_GeometricComplex - a
                self-consistent set of TimeInstants and TimePeriods</documentation>
        </annotation>
    </element>
    <!-- ......................... -->
    <complexType name="TimeGeometricComplexPropertyType">
        <sequence minOccurs="0">
            <element ref="swe:TimeGeometricComplex"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ===================================== -->
    <!-- ===== Time aggregates ====== -->
    <!-- ================================================================== -->
    <!-- ===== Explicit time aggregates ====== -->
    <!-- ================================================================== -->
    <complexType name="TimeObjectPropertyType">
        <annotation>
            <documentation>Property type not provided by GML</documentation>
        </annotation>
        <sequence minOccurs="0">
            <element ref="gml:_TimeObject"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ================================================================== -->
    <complexType name="TimeAggregateType">
        <annotation>
            <documentation>an arbitrary set of TimeObjects, often TimeInstants and
                TimePeriods</documentation>
        </annotation>
        <complexContent>
            <extension base="gml:AbstractTimeObjectType">
                <sequence>
                    <element form="qualified" maxOccurs="unbounded" name="member"
                        type="swe:TimeObjectPropertyType"/>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ......................... -->
    <element name="TimeAggregate" substitutionGroup="gml:_TimeObject" type="swe:TimeAggregateType">
        <annotation>
            <documentation>an arbitrary set of TimeObjects, often TimeInstants and
                TimePeriods</documentation>
        </annotation>
    </element>
    <!-- ......................... -->
    <complexType name="TimeAggregatePropertyType">
        <sequence minOccurs="0">
            <element ref="swe:TimeAggregate"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ===================================== -->
    <!-- ===== Implicit time aggregates ====== -->
    <!-- ================================================================== -->
    <complexType name="TimeGridType">
        <annotation>
            <documentation>A set of uniformly spaced time instants described using an implicit
                notation.       Follow pattern of (ISO 19123) spatial grids:    these have
                (dimension,axisName,extent(,origin,offsetVector))   For temporal case, dimension is
                fixed (1), axisName is fixed ("time")</documentation>
        </annotation>
        <complexContent>
            <extension base="gml:AbstractTimeComplexType">
                <sequence>
                    <element form="qualified" name="extent" type="swe:TimeGridEnvelopePropertyType"/>
                    <choice>
                        <element form="qualified" name="originPos" type="gml:TimePositionType">
                            <annotation>
                                <documentation>Simple-content time position</documentation>
                            </annotation>
                        </element>
                        <element form="qualified" name="origin" type="gml:TimeInstantPropertyType">
                            <annotation>
                                <documentation>Reference to an identified time
                                    instant</documentation>
                            </annotation>
                        </element>
                    </choice>
                    <choice>
                        <element form="qualified" name="offsetDuration" type="duration">
                            <annotation>
                                <documentation>XML Schema built-in simple type for duration: e.g.
                                    P1Y (1 year)                  P1M (1 month)
                                    P1DT12H (1 day 12 hours)                  PT5M (5 minutes)
                                    PT0.007S (7 milliseconds)</documentation>
                            </annotation>
                        </element>
                        <element form="qualified" name="offsetInterval"
                            type="gml:TimeIntervalLengthType">
                            <annotation>
                                <documentation>representation of the ISO 11404 model of a time
                                    interval length: e.g.                  value=1, unit="year"
                                    value=1, unit="other:month" (or see next)
                                    value=1, unit="year" radix="12" factor="1" (1/12 year)
                                    value=1.5, unit="day"                   value=36, unit="hour"
                                    value=5, unit="minute"                   value=7, unit="second"
                                    radix="10" factor="3" (7 milliseconds)</documentation>
                            </annotation>
                        </element>
                    </choice>
                    <element form="qualified" minOccurs="0" name="duration" type="duration"/>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ......................... -->
    <element abstract="true" name="TimeGrid" substitutionGroup="gml:_TimeComplex"
        type="swe:TimeGridType">
        <annotation>
            <documentation>A set of uniformly spaced time instants described using an implicit
                notation          Follow pattern of (ISO 19123) spatial grids:    these have
                (dimension,axisName,extent(,origin,offsetVector))   For temporal case, dimension is
                fixed (1), axisName is fixed ("time")</documentation>
        </annotation>
    </element>
    <!-- ......................... -->
    <complexType name="TimeGridPropertyType">
        <sequence minOccurs="0">
            <element ref="swe:TimeInstantGrid"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- =========================================================== -->
    <complexType name="TimeGridEnvelopePropertyType">
        <sequence>
            <element form="qualified" name="TimeGridEnvelope">
                <annotation>
                    <documentation>Grid extent specified in grid coordinates - i.e. 2
                        integers</documentation>
                </annotation>
                <complexType>
                    <sequence>
                        <element form="qualified" name="low" type="integer"/>
                        <element form="qualified" name="high" type="integer"/>
                    </sequence>
                </complexType>
            </element>
        </sequence>
    </complexType>
    <!-- ================================================================== -->
    <complexType name="TimeInstantGridType">
        <annotation>
            <documentation>Extend time instant grid with window size property</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:TimeGridType"> </extension>
        </complexContent>
    </complexType>
    <!-- ......................... -->
    <element name="TimeInstantGrid" substitutionGroup="swe:TimeGrid" type="swe:TimeInstantGridType">
        <annotation>
            <documentation>A set of uniformly spaced time instants described using an implicit
                notation</documentation>
        </annotation>
    </element>
    <!-- ......................... -->
    <complexType name="TimeInstantGridPropertyType">
        <sequence minOccurs="0">
            <element ref="swe:TimeInstantGrid"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ================================================================== -->
    <complexType name="TimeIntervalGridType">
        <annotation>
            <documentation>Extend time instant grid with window size property</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:TimeGridType">
                <sequence>
                    <choice>
                        <element form="qualified" name="windowDuration" type="duration">
                            <annotation>
                                <documentation>XML Schema built-in simple type for
                                    duration</documentation>
                            </annotation>
                        </element>
                        <element form="qualified" name="windowInterval"
                            type="gml:TimeIntervalLengthType">
                            <annotation>
                                <documentation>representation of the ISO 11404 model of a time
                                    interval length</documentation>
                            </annotation>
                        </element>
                    </choice>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ......................... -->
    <element name="TimeIntervalGrid" substitutionGroup="swe:TimeGrid"
        type="swe:TimeIntervalGridType">
        <annotation>
            <documentation>A set of uniformly spaced time intervals described using an implicit
                notation</documentation>
        </annotation>
    </element>
    <!-- ......................... -->
    <complexType name="TimeIntervalGridPropertyType">
        <sequence minOccurs="0">
            <element ref="swe:TimeIntervalGrid"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ================================================================== -->
    <!-- This version of sweCommon/1.0.0 was previously versioned as '1.0.1' . -->
    <annotation>
        <documentation>A basic schema for data aggregates (Records and Arrays), using terminology
            consistent with ISO 11404.     A schema for the description of the record is given in
            recordType.xsd      Copyright (c) 2007,2010 Open Geospatial Consortium.   To obtain
            additional rights of use, visit http://www.opengeospatial.org/legal/ .
        </documentation>
    </annotation>
    <!-- ============== -->
    <!-- ============== -->
    <element name="Item">
        <annotation>
            <documentation>An Item is an item of data of any type</documentation>
        </annotation>
    </element>
    <!-- ......  ...... -->
    <complexType name="ItemPropertyType">
        <sequence>
            <element ref="swe:Item"/>
        </sequence>
    </complexType>
    <!-- ============== -->
    <!-- ============== -->
    <complexType name="RecordType">
        <annotation>
            <documentation>A record is a list of fields</documentation>
        </annotation>
        <sequence>
            <element form="qualified" maxOccurs="unbounded" name="field" type="swe:ItemPropertyType">
                <annotation>
                    <documentation>A Record/field contains an item of data</documentation>
                </annotation>
            </element>
        </sequence>
        <attribute form="unqualified" name="RS" type="anyURI" use="optional">
            <annotation>
                <documentation>Optional pointer to record-type schema</documentation>
            </annotation>
        </attribute>
        <attribute form="unqualified" name="fieldCount" type="positiveInteger" use="optional">
            <annotation>
                <documentation>Optional count of the number of fields in the record.
                </documentation>
            </annotation>
        </attribute>
    </complexType>
    <!-- ......  ...... -->
    <element name="Record" type="swe:RecordType">
        <annotation>
            <documentation>A record is a list of fields</documentation>
        </annotation>
    </element>
    <!-- ......  ...... -->
    <complexType name="RecordPropertyType">
        <sequence>
            <element ref="swe:Record"/>
        </sequence>
    </complexType>
    <!-- ============== -->
    <!-- ============== -->
    <complexType name="ArrayType">
        <annotation>
            <documentation>An array is an indexed set of records of homogeneous type</documentation>
        </annotation>
        <sequence>
            <element form="qualified" maxOccurs="unbounded" name="element"
                type="swe:XMLDataPropertyType">
                <annotation>
                    <documentation>An Array/element contains an Item or a Record or an
                        Array</documentation>
                </annotation>
            </element>
        </sequence>
        <attribute form="unqualified" name="RS" type="anyURI" use="optional">
            <annotation>
                <documentation>Optional pointer to the record-type schema. This should be used when
                    the elements of the array are Records</documentation>
            </annotation>
        </attribute>
        <attribute form="unqualified" name="elementCount" type="positiveInteger" use="optional">
            <annotation>
                <documentation>Optional count of the number of elements in the array.
                </documentation>
            </annotation>
        </attribute>
    </complexType>
    <!-- ......  ...... -->
    <element name="Array" type="swe:ArrayType">
        <annotation>
            <documentation>An array is an indexed set of records of homogeneous type</documentation>
        </annotation>
    </element>
    <!-- ......  ...... -->
    <complexType name="ArrayPropertyType">
        <sequence>
            <element ref="swe:Array"/>
        </sequence>
    </complexType>
    <!-- ============== -->
    <complexType name="XMLDataPropertyType">
        <annotation>
            <documentation>Choice of Item or Record or Array - used in composing
                Arrays</documentation>
        </annotation>
        <group ref="swe:XMLData"/>
    </complexType>
    <!-- ============== -->
    <group name="XMLData">
        <annotation>
            <documentation>Convenience group that bundles all the soft-typed XML-encoded aggregates
                into a choice group</documentation>
        </annotation>
        <choice>
            <element ref="swe:Item"/>
            <element ref="swe:Record"/>
            <element ref="swe:Array"/>
        </choice>
    </group>
    <!-- ============== -->
    <!--========================-->
    <!-- ====================================================================== -->
    <complexType name="PhenomenonType">
        <annotation>
            <documentation>Basic Phenomenon definition, and head of substitution group of
                specialized phenomenon defs.     gml:description may be used for a more extensive
                description of the semantics, with a link to a definitive version (if available).
                gml:name should be used for the name or label.        Note: In GML 3.2 the
                gml:identifier element should be used for the identifier assigned by or preferred by
                the data provider.     This identifier will typically be in the form of a URN, for
                example following the OGC URN scheme    e.g. urn:x-ogc:def:phenomenon:OGC:Age
            </documentation>
        </annotation>
        <complexContent>
            <extension base="gml:DefinitionType"/>
        </complexContent>
    </complexType>
    <!-- .......... -->
    <element name="Phenomenon" substitutionGroup="gml:Definition" type="swe:PhenomenonType">
        <annotation>
            <documentation>Basic Phenomenon definition, and head of substitution group of
                specialized phenomenon defs. </documentation>
        </annotation>
    </element>
    <!-- .......... -->
    <complexType name="PhenomenonPropertyType">
        <sequence minOccurs="0">
            <element ref="swe:Phenomenon"/>
        </sequence>
        <attributeGroup ref="gml:AssociationAttributeGroup"/>
    </complexType>
    <!-- ====================================================================== -->
    <complexType name="ConstrainedPhenomenonType">
        <annotation>
            <documentation>A scalar Phenomenon is defined by adding constraints to an existing
                property.</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:PhenomenonType">
                <sequence>
                    <element name="base" type="swe:PhenomenonPropertyType">
                        <annotation>
                            <documentation>Property that forms the basis for generating a set of
                                more refined Phenomena; e.g. Chemical Composition,
                                Radiance</documentation>
                        </annotation>
                    </element>
                    <element maxOccurs="unbounded" minOccurs="0" name="otherConstraint"
                        type="string">
                        <annotation>
                            <documentation>Constraints that cannot be expressed as values of an
                                orthogonal/helper phenomenon</documentation>
                        </annotation>
                    </element>
                    <element maxOccurs="unbounded" minOccurs="0" name="singleConstraint"
                        type="swe:TypedValuePropertyType">
                        <annotation>
                            <documentation>Constraint expressed as a value or range of an
                                orthogonal/helper phenomenon</documentation>
                        </annotation>
                    </element>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ........................................ -->
    <element name="ConstrainedPhenomenon" substitutionGroup="swe:Phenomenon"
        type="swe:ConstrainedPhenomenonType">
        <annotation>
            <documentation>Description of a scalar Phenomenon defined by adding constraints to a
                property previously defined elsewhere.</documentation>
        </annotation>
    </element>
    <!-- ====================================================================== -->
    <!-- ====================================================================== -->
    <complexType abstract="true" name="CompoundPhenomenonType">
        <annotation>
            <documentation>Description of a set of Phenomena.      CompoundPhenomenon is the
                abstract head of a substitution group of specialized compound
                phenomena</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:PhenomenonType">
                <attribute name="dimension" type="positiveInteger" use="required">
                    <annotation>
                        <documentation>The number of components in the tuple</documentation>
                    </annotation>
                </attribute>
            </extension>
        </complexContent>
    </complexType>
    <!-- ........................................ -->
    <element abstract="true" name="CompoundPhenomenon" substitutionGroup="swe:Phenomenon"
        type="swe:CompoundPhenomenonType">
        <annotation>
            <documentation>Description of a set of Phenomena.      CompoundPhenomenon is the
                abstract head of a substitution group of specialized compound
                phenomena</documentation>
        </annotation>
    </element>
    <!-- ====================================================================== -->
    <complexType name="CompositePhenomenonType">
        <annotation>
            <documentation>A Phenomenon defined as a set of explicitly enumerated components which
                may or may not be related to one another</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:CompoundPhenomenonType">
                <sequence>
                    <element minOccurs="0" name="base" type="swe:PhenomenonPropertyType">
                        <annotation>
                            <documentation>Optional phenomenon that forms the basis for generating
                                more specialized composite Phenomenon by adding more
                                components</documentation>
                        </annotation>
                    </element>
                    <element maxOccurs="unbounded" name="component"
                        type="swe:PhenomenonPropertyType"/>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ........................................ -->
    <element name="CompositePhenomenon" substitutionGroup="swe:CompoundPhenomenon"
        type="swe:CompositePhenomenonType">
        <annotation>
            <documentation>A Phenomenon defined as a set of explicitly enumerated components which
                may or may not be related to one another</documentation>
        </annotation>
    </element>
    <!-- ====================================================================== -->
    <complexType name="PhenomenonSeriesType">
        <annotation>
            <documentation>A phenomenon defined as a base property convolved with a set of
                constraints       The set of constraints may be either       * an explicit set of
                soft-typed measures, intervals and categories       * one or more lists of
                soft-typed measures, intervals and categories       * one or more sequences of
                soft-typed measures and intervals</documentation>
        </annotation>
        <complexContent>
            <extension base="swe:CompoundPhenomenonType">
                <sequence>
                    <element name="base" type="swe:PhenomenonPropertyType">
                        <annotation>
                            <documentation>Phenomenon that forms the basis for generating a set of
                                more refined Phenomena; e.g. Chemical Composition,
                                Radiance</documentation>
                        </annotation>
                    </element>
                    <element maxOccurs="unbounded" name="constraintList"
                        type="swe:TypedValueListPropertyType">
                        <annotation>
                            <documentation>A set of values of some secondary property that
                                constraints the basePhenomenon to generate a Phenomenon set.
                                If more than one set of constraints are possible, then these are
                                applied simultaneously to generate</documentation>
                        </annotation>
                    </element>
                    <element maxOccurs="unbounded" minOccurs="0" name="otherConstraint"
                        type="string">
                        <annotation>
                            <documentation>Other constraints are described in text</documentation>
                        </annotation>
                    </element>
                </sequence>
            </extension>
        </complexContent>
    </complexType>
    <!-- ........................................ -->
    <element name="PhenomenonSeries" substitutionGroup="swe:CompoundPhenomenon"
        type="swe:PhenomenonSeriesType">
        <annotation>
            <documentation>A phenomenon defined as a base property convolved with a set of
                constraints       The set of constraints may be either       * an explicit set of
                soft-typed measures, intervals and categories       * one or more lists of
                soft-typed measures, intervals and categories       * one or more sequences of
                soft-typed measures and intervals</documentation>
        </annotation>
    </element>
    <!-- ====================================================================== -->
    <!-- ====================================================================== -->
</schema>
